// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `osmformat.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:OSMPBF.HeaderBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HeaderBlock {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.bbox)
    pub bbox: ::protobuf::MessageField<HeaderBBox>,
    ///  Additional tags to aid in parsing this dataset 
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.required_features)
    pub required_features: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.optional_features)
    pub optional_features: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.writingprogram)
    pub writingprogram: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.source)
    pub source: ::std::option::Option<::std::string::String>,
    ///  Replication timestamp, expressed in seconds since the epoch,
    ///  otherwise the same value as in the "timestamp=..." field
    ///  in the state.txt file used by Osmosis.
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.osmosis_replication_timestamp)
    pub osmosis_replication_timestamp: ::std::option::Option<i64>,
    ///  Replication sequence number (sequenceNumber in state.txt).
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.osmosis_replication_sequence_number)
    pub osmosis_replication_sequence_number: ::std::option::Option<i64>,
    ///  Replication base URL (from Osmosis' configuration.txt file).
    // @@protoc_insertion_point(field:OSMPBF.HeaderBlock.osmosis_replication_base_url)
    pub osmosis_replication_base_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.HeaderBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderBlock {
    fn default() -> &'a HeaderBlock {
        <HeaderBlock as ::protobuf::Message>::default_instance()
    }
}

impl HeaderBlock {
    pub fn new() -> HeaderBlock {
        ::std::default::Default::default()
    }

    // optional string writingprogram = 16;

    pub fn writingprogram(&self) -> &str {
        match self.writingprogram.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_writingprogram(&mut self) {
        self.writingprogram = ::std::option::Option::None;
    }

    pub fn has_writingprogram(&self) -> bool {
        self.writingprogram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writingprogram(&mut self, v: ::std::string::String) {
        self.writingprogram = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_writingprogram(&mut self) -> &mut ::std::string::String {
        if self.writingprogram.is_none() {
            self.writingprogram = ::std::option::Option::Some(::std::string::String::new());
        }
        self.writingprogram.as_mut().unwrap()
    }

    // Take field
    pub fn take_writingprogram(&mut self) -> ::std::string::String {
        self.writingprogram.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 17;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 osmosis_replication_timestamp = 32;

    pub fn osmosis_replication_timestamp(&self) -> i64 {
        self.osmosis_replication_timestamp.unwrap_or(0)
    }

    pub fn clear_osmosis_replication_timestamp(&mut self) {
        self.osmosis_replication_timestamp = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_timestamp(&self) -> bool {
        self.osmosis_replication_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_timestamp(&mut self, v: i64) {
        self.osmosis_replication_timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 osmosis_replication_sequence_number = 33;

    pub fn osmosis_replication_sequence_number(&self) -> i64 {
        self.osmosis_replication_sequence_number.unwrap_or(0)
    }

    pub fn clear_osmosis_replication_sequence_number(&mut self) {
        self.osmosis_replication_sequence_number = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_sequence_number(&self) -> bool {
        self.osmosis_replication_sequence_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_sequence_number(&mut self, v: i64) {
        self.osmosis_replication_sequence_number = ::std::option::Option::Some(v);
    }

    // optional string osmosis_replication_base_url = 34;

    pub fn osmosis_replication_base_url(&self) -> &str {
        match self.osmosis_replication_base_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_osmosis_replication_base_url(&mut self) {
        self.osmosis_replication_base_url = ::std::option::Option::None;
    }

    pub fn has_osmosis_replication_base_url(&self) -> bool {
        self.osmosis_replication_base_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osmosis_replication_base_url(&mut self, v: ::std::string::String) {
        self.osmosis_replication_base_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osmosis_replication_base_url(&mut self) -> &mut ::std::string::String {
        if self.osmosis_replication_base_url.is_none() {
            self.osmosis_replication_base_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.osmosis_replication_base_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_osmosis_replication_base_url(&mut self) -> ::std::string::String {
        self.osmosis_replication_base_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HeaderBBox>(
            "bbox",
            |m: &HeaderBlock| { &m.bbox },
            |m: &mut HeaderBlock| { &mut m.bbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "required_features",
            |m: &HeaderBlock| { &m.required_features },
            |m: &mut HeaderBlock| { &mut m.required_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "optional_features",
            |m: &HeaderBlock| { &m.optional_features },
            |m: &mut HeaderBlock| { &mut m.optional_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "writingprogram",
            |m: &HeaderBlock| { &m.writingprogram },
            |m: &mut HeaderBlock| { &mut m.writingprogram },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source",
            |m: &HeaderBlock| { &m.source },
            |m: &mut HeaderBlock| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmosis_replication_timestamp",
            |m: &HeaderBlock| { &m.osmosis_replication_timestamp },
            |m: &mut HeaderBlock| { &mut m.osmosis_replication_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmosis_replication_sequence_number",
            |m: &HeaderBlock| { &m.osmosis_replication_sequence_number },
            |m: &mut HeaderBlock| { &mut m.osmosis_replication_sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osmosis_replication_base_url",
            |m: &HeaderBlock| { &m.osmosis_replication_base_url },
            |m: &mut HeaderBlock| { &mut m.osmosis_replication_base_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderBlock>(
            "HeaderBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeaderBlock {
    const NAME: &'static str = "HeaderBlock";

    fn is_initialized(&self) -> bool {
        for v in &self.bbox {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bbox)?;
                },
                34 => {
                    self.required_features.push(is.read_string()?);
                },
                42 => {
                    self.optional_features.push(is.read_string()?);
                },
                130 => {
                    self.writingprogram = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                256 => {
                    self.osmosis_replication_timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                264 => {
                    self.osmosis_replication_sequence_number = ::std::option::Option::Some(is.read_int64()?);
                },
                274 => {
                    self.osmosis_replication_base_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bbox.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.required_features {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.optional_features {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(v) = self.writingprogram.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.osmosis_replication_timestamp {
            my_size += ::protobuf::rt::int64_size(32, v);
        }
        if let Some(v) = self.osmosis_replication_sequence_number {
            my_size += ::protobuf::rt::int64_size(33, v);
        }
        if let Some(v) = self.osmosis_replication_base_url.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bbox.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.required_features {
            os.write_string(4, &v)?;
        };
        for v in &self.optional_features {
            os.write_string(5, &v)?;
        };
        if let Some(v) = self.writingprogram.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.osmosis_replication_timestamp {
            os.write_int64(32, v)?;
        }
        if let Some(v) = self.osmosis_replication_sequence_number {
            os.write_int64(33, v)?;
        }
        if let Some(v) = self.osmosis_replication_base_url.as_ref() {
            os.write_string(34, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderBlock {
        HeaderBlock::new()
    }

    fn clear(&mut self) {
        self.bbox.clear();
        self.required_features.clear();
        self.optional_features.clear();
        self.writingprogram = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.osmosis_replication_timestamp = ::std::option::Option::None;
        self.osmosis_replication_sequence_number = ::std::option::Option::None;
        self.osmosis_replication_base_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderBlock {
        static instance: HeaderBlock = HeaderBlock {
            bbox: ::protobuf::MessageField::none(),
            required_features: ::std::vec::Vec::new(),
            optional_features: ::std::vec::Vec::new(),
            writingprogram: ::std::option::Option::None,
            source: ::std::option::Option::None,
            osmosis_replication_timestamp: ::std::option::Option::None,
            osmosis_replication_sequence_number: ::std::option::Option::None,
            osmosis_replication_base_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeaderBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeaderBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeaderBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OSMPBF.HeaderBBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HeaderBBox {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.left)
    pub left: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.right)
    pub right: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.top)
    pub top: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.HeaderBBox.bottom)
    pub bottom: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.HeaderBBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HeaderBBox {
    fn default() -> &'a HeaderBBox {
        <HeaderBBox as ::protobuf::Message>::default_instance()
    }
}

impl HeaderBBox {
    pub fn new() -> HeaderBBox {
        ::std::default::Default::default()
    }

    // required sint64 left = 1;

    pub fn left(&self) -> i64 {
        self.left.unwrap_or(0)
    }

    pub fn clear_left(&mut self) {
        self.left = ::std::option::Option::None;
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: i64) {
        self.left = ::std::option::Option::Some(v);
    }

    // required sint64 right = 2;

    pub fn right(&self) -> i64 {
        self.right.unwrap_or(0)
    }

    pub fn clear_right(&mut self) {
        self.right = ::std::option::Option::None;
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: i64) {
        self.right = ::std::option::Option::Some(v);
    }

    // required sint64 top = 3;

    pub fn top(&self) -> i64 {
        self.top.unwrap_or(0)
    }

    pub fn clear_top(&mut self) {
        self.top = ::std::option::Option::None;
    }

    pub fn has_top(&self) -> bool {
        self.top.is_some()
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: i64) {
        self.top = ::std::option::Option::Some(v);
    }

    // required sint64 bottom = 4;

    pub fn bottom(&self) -> i64 {
        self.bottom.unwrap_or(0)
    }

    pub fn clear_bottom(&mut self) {
        self.bottom = ::std::option::Option::None;
    }

    pub fn has_bottom(&self) -> bool {
        self.bottom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: i64) {
        self.bottom = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "left",
            |m: &HeaderBBox| { &m.left },
            |m: &mut HeaderBBox| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "right",
            |m: &HeaderBBox| { &m.right },
            |m: &mut HeaderBBox| { &mut m.right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "top",
            |m: &HeaderBBox| { &m.top },
            |m: &mut HeaderBBox| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bottom",
            |m: &HeaderBBox| { &m.bottom },
            |m: &mut HeaderBBox| { &mut m.bottom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HeaderBBox>(
            "HeaderBBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HeaderBBox {
    const NAME: &'static str = "HeaderBBox";

    fn is_initialized(&self) -> bool {
        if self.left.is_none() {
            return false;
        }
        if self.right.is_none() {
            return false;
        }
        if self.top.is_none() {
            return false;
        }
        if self.bottom.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.left = ::std::option::Option::Some(is.read_sint64()?);
                },
                16 => {
                    self.right = ::std::option::Option::Some(is.read_sint64()?);
                },
                24 => {
                    self.top = ::std::option::Option::Some(is.read_sint64()?);
                },
                32 => {
                    self.bottom = ::std::option::Option::Some(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.left {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        if let Some(v) = self.right {
            my_size += ::protobuf::rt::sint64_size(2, v);
        }
        if let Some(v) = self.top {
            my_size += ::protobuf::rt::sint64_size(3, v);
        }
        if let Some(v) = self.bottom {
            my_size += ::protobuf::rt::sint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.left {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.right {
            os.write_sint64(2, v)?;
        }
        if let Some(v) = self.top {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.bottom {
            os.write_sint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HeaderBBox {
        HeaderBBox::new()
    }

    fn clear(&mut self) {
        self.left = ::std::option::Option::None;
        self.right = ::std::option::Option::None;
        self.top = ::std::option::Option::None;
        self.bottom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HeaderBBox {
        static instance: HeaderBBox = HeaderBBox {
            left: ::std::option::Option::None,
            right: ::std::option::Option::None,
            top: ::std::option::Option::None,
            bottom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HeaderBBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HeaderBBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HeaderBBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderBBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OSMPBF.PrimitiveBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrimitiveBlock {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.stringtable)
    pub stringtable: ::protobuf::MessageField<StringTable>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.primitivegroup)
    pub primitivegroup: ::std::vec::Vec<PrimitiveGroup>,
    ///  Granularity, units of nanodegrees, used to store coordinates in this block.
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.granularity)
    pub granularity: ::std::option::Option<i32>,
    ///  Offset value between the output coordinates and the granularity grid in units of nanodegrees.
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.lat_offset)
    pub lat_offset: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.lon_offset)
    pub lon_offset: ::std::option::Option<i64>,
    ///  Granularity of dates, normally represented in units of milliseconds since the 1970 epoch.
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveBlock.date_granularity)
    pub date_granularity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.PrimitiveBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimitiveBlock {
    fn default() -> &'a PrimitiveBlock {
        <PrimitiveBlock as ::protobuf::Message>::default_instance()
    }
}

impl PrimitiveBlock {
    pub fn new() -> PrimitiveBlock {
        ::std::default::Default::default()
    }

    // optional int32 granularity = 17;

    pub fn granularity(&self) -> i32 {
        self.granularity.unwrap_or(100i32)
    }

    pub fn clear_granularity(&mut self) {
        self.granularity = ::std::option::Option::None;
    }

    pub fn has_granularity(&self) -> bool {
        self.granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_granularity(&mut self, v: i32) {
        self.granularity = ::std::option::Option::Some(v);
    }

    // optional int64 lat_offset = 19;

    pub fn lat_offset(&self) -> i64 {
        self.lat_offset.unwrap_or(0i64)
    }

    pub fn clear_lat_offset(&mut self) {
        self.lat_offset = ::std::option::Option::None;
    }

    pub fn has_lat_offset(&self) -> bool {
        self.lat_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat_offset(&mut self, v: i64) {
        self.lat_offset = ::std::option::Option::Some(v);
    }

    // optional int64 lon_offset = 20;

    pub fn lon_offset(&self) -> i64 {
        self.lon_offset.unwrap_or(0i64)
    }

    pub fn clear_lon_offset(&mut self) {
        self.lon_offset = ::std::option::Option::None;
    }

    pub fn has_lon_offset(&self) -> bool {
        self.lon_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon_offset(&mut self, v: i64) {
        self.lon_offset = ::std::option::Option::Some(v);
    }

    // optional int32 date_granularity = 18;

    pub fn date_granularity(&self) -> i32 {
        self.date_granularity.unwrap_or(1000i32)
    }

    pub fn clear_date_granularity(&mut self) {
        self.date_granularity = ::std::option::Option::None;
    }

    pub fn has_date_granularity(&self) -> bool {
        self.date_granularity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_granularity(&mut self, v: i32) {
        self.date_granularity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringTable>(
            "stringtable",
            |m: &PrimitiveBlock| { &m.stringtable },
            |m: &mut PrimitiveBlock| { &mut m.stringtable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "primitivegroup",
            |m: &PrimitiveBlock| { &m.primitivegroup },
            |m: &mut PrimitiveBlock| { &mut m.primitivegroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "granularity",
            |m: &PrimitiveBlock| { &m.granularity },
            |m: &mut PrimitiveBlock| { &mut m.granularity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lat_offset",
            |m: &PrimitiveBlock| { &m.lat_offset },
            |m: &mut PrimitiveBlock| { &mut m.lat_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lon_offset",
            |m: &PrimitiveBlock| { &m.lon_offset },
            |m: &mut PrimitiveBlock| { &mut m.lon_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_granularity",
            |m: &PrimitiveBlock| { &m.date_granularity },
            |m: &mut PrimitiveBlock| { &mut m.date_granularity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimitiveBlock>(
            "PrimitiveBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimitiveBlock {
    const NAME: &'static str = "PrimitiveBlock";

    fn is_initialized(&self) -> bool {
        if self.stringtable.is_none() {
            return false;
        }
        for v in &self.stringtable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.primitivegroup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stringtable)?;
                },
                18 => {
                    self.primitivegroup.push(is.read_message()?);
                },
                136 => {
                    self.granularity = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.lat_offset = ::std::option::Option::Some(is.read_int64()?);
                },
                160 => {
                    self.lon_offset = ::std::option::Option::Some(is.read_int64()?);
                },
                144 => {
                    self.date_granularity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stringtable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.primitivegroup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.granularity {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.lat_offset {
            my_size += ::protobuf::rt::int64_size(19, v);
        }
        if let Some(v) = self.lon_offset {
            my_size += ::protobuf::rt::int64_size(20, v);
        }
        if let Some(v) = self.date_granularity {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stringtable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.primitivegroup {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.granularity {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.lat_offset {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.lon_offset {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.date_granularity {
            os.write_int32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimitiveBlock {
        PrimitiveBlock::new()
    }

    fn clear(&mut self) {
        self.stringtable.clear();
        self.primitivegroup.clear();
        self.granularity = ::std::option::Option::None;
        self.lat_offset = ::std::option::Option::None;
        self.lon_offset = ::std::option::Option::None;
        self.date_granularity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimitiveBlock {
        static instance: PrimitiveBlock = PrimitiveBlock {
            stringtable: ::protobuf::MessageField::none(),
            primitivegroup: ::std::vec::Vec::new(),
            granularity: ::std::option::Option::None,
            lat_offset: ::std::option::Option::None,
            lon_offset: ::std::option::Option::None,
            date_granularity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimitiveBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimitiveBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimitiveBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Group of OSMPrimitives. All primitives in a group must be the same type.
// @@protoc_insertion_point(message:OSMPBF.PrimitiveGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrimitiveGroup {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.nodes)
    pub nodes: ::std::vec::Vec<Node>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.dense)
    pub dense: ::protobuf::MessageField<DenseNodes>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.ways)
    pub ways: ::std::vec::Vec<Way>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.relations)
    pub relations: ::std::vec::Vec<Relation>,
    // @@protoc_insertion_point(field:OSMPBF.PrimitiveGroup.changesets)
    pub changesets: ::std::vec::Vec<ChangeSet>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.PrimitiveGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimitiveGroup {
    fn default() -> &'a PrimitiveGroup {
        <PrimitiveGroup as ::protobuf::Message>::default_instance()
    }
}

impl PrimitiveGroup {
    pub fn new() -> PrimitiveGroup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &PrimitiveGroup| { &m.nodes },
            |m: &mut PrimitiveGroup| { &mut m.nodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DenseNodes>(
            "dense",
            |m: &PrimitiveGroup| { &m.dense },
            |m: &mut PrimitiveGroup| { &mut m.dense },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ways",
            |m: &PrimitiveGroup| { &m.ways },
            |m: &mut PrimitiveGroup| { &mut m.ways },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "relations",
            |m: &PrimitiveGroup| { &m.relations },
            |m: &mut PrimitiveGroup| { &mut m.relations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changesets",
            |m: &PrimitiveGroup| { &m.changesets },
            |m: &mut PrimitiveGroup| { &mut m.changesets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimitiveGroup>(
            "PrimitiveGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimitiveGroup {
    const NAME: &'static str = "PrimitiveGroup";

    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dense {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ways {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.changesets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.nodes.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dense)?;
                },
                26 => {
                    self.ways.push(is.read_message()?);
                },
                34 => {
                    self.relations.push(is.read_message()?);
                },
                42 => {
                    self.changesets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.dense.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ways {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.changesets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.dense.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ways {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.relations {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.changesets {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimitiveGroup {
        PrimitiveGroup::new()
    }

    fn clear(&mut self) {
        self.nodes.clear();
        self.dense.clear();
        self.ways.clear();
        self.relations.clear();
        self.changesets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimitiveGroup {
        static instance: PrimitiveGroup = PrimitiveGroup {
            nodes: ::std::vec::Vec::new(),
            dense: ::protobuf::MessageField::none(),
            ways: ::std::vec::Vec::new(),
            relations: ::std::vec::Vec::new(),
            changesets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimitiveGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimitiveGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimitiveGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// * String table, contains the common strings in each block.
///
/// Note that we reserve index '0' as a delimiter, so the entry at that
/// index in the table is ALWAYS blank and unused.
///
// @@protoc_insertion_point(message:OSMPBF.StringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StringTable {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.StringTable.s)
    pub s: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.StringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringTable {
    fn default() -> &'a StringTable {
        <StringTable as ::protobuf::Message>::default_instance()
    }
}

impl StringTable {
    pub fn new() -> StringTable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "s",
            |m: &StringTable| { &m.s },
            |m: &mut StringTable| { &mut m.s },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringTable>(
            "StringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StringTable {
    const NAME: &'static str = "StringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.s.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.s {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.s {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringTable {
        StringTable::new()
    }

    fn clear(&mut self) {
        self.s.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringTable {
        static instance: StringTable = StringTable {
            s: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Optional metadata that may be included into each primitive. 
// @@protoc_insertion_point(message:OSMPBF.Info)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Info {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Info.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OSMPBF.Info.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Info.changeset)
    pub changeset: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Info.uid)
    pub uid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OSMPBF.Info.user_sid)
    pub user_sid: ::std::option::Option<u32>,
    ///  The visible flag is used to store history information. It indicates that
    ///  the current object version has been created by a delete operation on the
    ///  OSM API.
    ///  When a writer sets this flag, it MUST add a required_features tag with
    ///  value "HistoricalInformation" to the HeaderBlock.
    ///  If this flag is not available for some object it MUST be assumed to be
    ///  true if the file has the required_features tag "HistoricalInformation"
    ///  set.
    // @@protoc_insertion_point(field:OSMPBF.Info.visible)
    pub visible: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Info.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Info {
    fn default() -> &'a Info {
        <Info as ::protobuf::Message>::default_instance()
    }
}

impl Info {
    pub fn new() -> Info {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(-1i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 changeset = 3;

    pub fn changeset(&self) -> i64 {
        self.changeset.unwrap_or(0)
    }

    pub fn clear_changeset(&mut self) {
        self.changeset = ::std::option::Option::None;
    }

    pub fn has_changeset(&self) -> bool {
        self.changeset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeset(&mut self, v: i64) {
        self.changeset = ::std::option::Option::Some(v);
    }

    // optional int32 uid = 4;

    pub fn uid(&self) -> i32 {
        self.uid.unwrap_or(0)
    }

    pub fn clear_uid(&mut self) {
        self.uid = ::std::option::Option::None;
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: i32) {
        self.uid = ::std::option::Option::Some(v);
    }

    // optional uint32 user_sid = 5;

    pub fn user_sid(&self) -> u32 {
        self.user_sid.unwrap_or(0)
    }

    pub fn clear_user_sid(&mut self) {
        self.user_sid = ::std::option::Option::None;
    }

    pub fn has_user_sid(&self) -> bool {
        self.user_sid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_sid(&mut self, v: u32) {
        self.user_sid = ::std::option::Option::Some(v);
    }

    // optional bool visible = 6;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &Info| { &m.version },
            |m: &mut Info| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &Info| { &m.timestamp },
            |m: &mut Info| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changeset",
            |m: &Info| { &m.changeset },
            |m: &mut Info| { &mut m.changeset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uid",
            |m: &Info| { &m.uid },
            |m: &mut Info| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_sid",
            |m: &Info| { &m.user_sid },
            |m: &mut Info| { &mut m.user_sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &Info| { &m.visible },
            |m: &mut Info| { &mut m.visible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Info>(
            "Info",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Info {
    const NAME: &'static str = "Info";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.changeset = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.uid = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.user_sid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.changeset {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.uid {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.user_sid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.changeset {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.uid {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.user_sid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Info {
        Info::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.changeset = ::std::option::Option::None;
        self.uid = ::std::option::Option::None;
        self.user_sid = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Info {
        static instance: Info = Info {
            version: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            changeset: ::std::option::Option::None,
            uid: ::std::option::Option::None,
            user_sid: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Info {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Info").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Info {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Info {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// * Optional metadata that may be included into each primitive. Special dense format used in DenseNodes. 
// @@protoc_insertion_point(message:OSMPBF.DenseInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DenseInfo {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.version)
    pub version: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.timestamp)
    pub timestamp: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.changeset)
    pub changeset: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.uid)
    pub uid: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.user_sid)
    pub user_sid: ::std::vec::Vec<i32>,
    ///  The visible flag is used to store history information. It indicates that
    ///  the current object version has been created by a delete operation on the
    ///  OSM API.
    ///  When a writer sets this flag, it MUST add a required_features tag with
    ///  value "HistoricalInformation" to the HeaderBlock.
    ///  If this flag is not available for some object it MUST be assumed to be
    ///  true if the file has the required_features tag "HistoricalInformation"
    ///  set.
    // @@protoc_insertion_point(field:OSMPBF.DenseInfo.visible)
    pub visible: ::std::vec::Vec<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.DenseInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DenseInfo {
    fn default() -> &'a DenseInfo {
        <DenseInfo as ::protobuf::Message>::default_instance()
    }
}

impl DenseInfo {
    pub fn new() -> DenseInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "version",
            |m: &DenseInfo| { &m.version },
            |m: &mut DenseInfo| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "timestamp",
            |m: &DenseInfo| { &m.timestamp },
            |m: &mut DenseInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changeset",
            |m: &DenseInfo| { &m.changeset },
            |m: &mut DenseInfo| { &mut m.changeset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uid",
            |m: &DenseInfo| { &m.uid },
            |m: &mut DenseInfo| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_sid",
            |m: &DenseInfo| { &m.user_sid },
            |m: &mut DenseInfo| { &mut m.user_sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "visible",
            |m: &DenseInfo| { &m.visible },
            |m: &mut DenseInfo| { &mut m.visible },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DenseInfo>(
            "DenseInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DenseInfo {
    const NAME: &'static str = "DenseInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.version)?;
                },
                8 => {
                    self.version.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_sint64_into(&mut self.timestamp)?;
                },
                16 => {
                    self.timestamp.push(is.read_sint64()?);
                },
                26 => {
                    is.read_repeated_packed_sint64_into(&mut self.changeset)?;
                },
                24 => {
                    self.changeset.push(is.read_sint64()?);
                },
                34 => {
                    is.read_repeated_packed_sint32_into(&mut self.uid)?;
                },
                32 => {
                    self.uid.push(is.read_sint32()?);
                },
                42 => {
                    is.read_repeated_packed_sint32_into(&mut self.user_sid)?;
                },
                40 => {
                    self.user_sid.push(is.read_sint32()?);
                },
                50 => {
                    is.read_repeated_packed_bool_into(&mut self.visible)?;
                },
                48 => {
                    self.visible.push(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_int32_size(1, &self.version);
        my_size += ::protobuf::rt::vec_packed_sint64_size(2, &self.timestamp);
        my_size += ::protobuf::rt::vec_packed_sint64_size(3, &self.changeset);
        my_size += ::protobuf::rt::vec_packed_sint32_size(4, &self.uid);
        my_size += ::protobuf::rt::vec_packed_sint32_size(5, &self.user_sid);
        my_size += ::protobuf::rt::vec_packed_bool_size(6, &self.visible);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_int32(1, &self.version)?;
        os.write_repeated_packed_sint64(2, &self.timestamp)?;
        os.write_repeated_packed_sint64(3, &self.changeset)?;
        os.write_repeated_packed_sint32(4, &self.uid)?;
        os.write_repeated_packed_sint32(5, &self.user_sid)?;
        os.write_repeated_packed_bool(6, &self.visible)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DenseInfo {
        DenseInfo::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.timestamp.clear();
        self.changeset.clear();
        self.uid.clear();
        self.user_sid.clear();
        self.visible.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DenseInfo {
        static instance: DenseInfo = DenseInfo {
            version: ::std::vec::Vec::new(),
            timestamp: ::std::vec::Vec::new(),
            changeset: ::std::vec::Vec::new(),
            uid: ::std::vec::Vec::new(),
            user_sid: ::std::vec::Vec::new(),
            visible: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DenseInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DenseInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DenseInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  This is kept for backwards compatibility but not used anywhere.
// @@protoc_insertion_point(message:OSMPBF.ChangeSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChangeSet {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.ChangeSet.id)
    pub id: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.ChangeSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChangeSet {
    fn default() -> &'a ChangeSet {
        <ChangeSet as ::protobuf::Message>::default_instance()
    }
}

impl ChangeSet {
    pub fn new() -> ChangeSet {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ChangeSet| { &m.id },
            |m: &mut ChangeSet| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeSet>(
            "ChangeSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChangeSet {
    const NAME: &'static str = "ChangeSet";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChangeSet {
        ChangeSet::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChangeSet {
        static instance: ChangeSet = ChangeSet {
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChangeSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChangeSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChangeSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangeSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OSMPBF.Node)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Node {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Node.id)
    pub id: ::std::option::Option<i64>,
    ///  Parallel arrays.
    // @@protoc_insertion_point(field:OSMPBF.Node.keys)
    pub keys: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Node.vals)
    pub vals: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Node.info)
    pub info: ::protobuf::MessageField<Info>,
    // @@protoc_insertion_point(field:OSMPBF.Node.lat)
    pub lat: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Node.lon)
    pub lon: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Node.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // required sint64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required sint64 lat = 8;

    pub fn lat(&self) -> i64 {
        self.lat.unwrap_or(0)
    }

    pub fn clear_lat(&mut self) {
        self.lat = ::std::option::Option::None;
    }

    pub fn has_lat(&self) -> bool {
        self.lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: i64) {
        self.lat = ::std::option::Option::Some(v);
    }

    // required sint64 lon = 9;

    pub fn lon(&self) -> i64 {
        self.lon.unwrap_or(0)
    }

    pub fn clear_lon(&mut self) {
        self.lon = ::std::option::Option::None;
    }

    pub fn has_lon(&self) -> bool {
        self.lon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lon(&mut self, v: i64) {
        self.lon = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Node| { &m.id },
            |m: &mut Node| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Node| { &m.keys },
            |m: &mut Node| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vals",
            |m: &Node| { &m.vals },
            |m: &mut Node| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &Node| { &m.info },
            |m: &mut Node| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lat",
            |m: &Node| { &m.lat },
            |m: &mut Node| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lon",
            |m: &Node| { &m.lon },
            |m: &mut Node| { &mut m.lon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
            "Node",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Node {
    const NAME: &'static str = "Node";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.lat.is_none() {
            return false;
        }
        if self.lon.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_sint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.vals)?;
                },
                24 => {
                    self.vals.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                64 => {
                    self.lat = ::std::option::Option::Some(is.read_sint64()?);
                },
                72 => {
                    self.lon = ::std::option::Option::Some(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::sint64_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.keys);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.vals);
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lat {
            my_size += ::protobuf::rt::sint64_size(8, v);
        }
        if let Some(v) = self.lon {
            my_size += ::protobuf::rt::sint64_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_sint64(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.keys)?;
        os.write_repeated_packed_uint32(3, &self.vals)?;
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.lat {
            os.write_sint64(8, v)?;
        }
        if let Some(v) = self.lon {
            os.write_sint64(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Node {
        Node::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.lat = ::std::option::Option::None;
        self.lon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Node {
        static instance: Node = Node {
            id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            vals: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            lat: ::std::option::Option::None,
            lon: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Node {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Node").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OSMPBF.DenseNodes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DenseNodes {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.id)
    pub id: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.denseinfo)
    pub denseinfo: ::protobuf::MessageField<DenseInfo>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.lat)
    pub lat: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.lon)
    pub lon: ::std::vec::Vec<i64>,
    ///  Special packing of keys and vals into one array. May be empty if all nodes in this block are tagless.
    // @@protoc_insertion_point(field:OSMPBF.DenseNodes.keys_vals)
    pub keys_vals: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.DenseNodes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DenseNodes {
    fn default() -> &'a DenseNodes {
        <DenseNodes as ::protobuf::Message>::default_instance()
    }
}

impl DenseNodes {
    pub fn new() -> DenseNodes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "id",
            |m: &DenseNodes| { &m.id },
            |m: &mut DenseNodes| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DenseInfo>(
            "denseinfo",
            |m: &DenseNodes| { &m.denseinfo },
            |m: &mut DenseNodes| { &mut m.denseinfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lat",
            |m: &DenseNodes| { &m.lat },
            |m: &mut DenseNodes| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lon",
            |m: &DenseNodes| { &m.lon },
            |m: &mut DenseNodes| { &mut m.lon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys_vals",
            |m: &DenseNodes| { &m.keys_vals },
            |m: &mut DenseNodes| { &mut m.keys_vals },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DenseNodes>(
            "DenseNodes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DenseNodes {
    const NAME: &'static str = "DenseNodes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_sint64_into(&mut self.id)?;
                },
                8 => {
                    self.id.push(is.read_sint64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.denseinfo)?;
                },
                66 => {
                    is.read_repeated_packed_sint64_into(&mut self.lat)?;
                },
                64 => {
                    self.lat.push(is.read_sint64()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.lon)?;
                },
                72 => {
                    self.lon.push(is.read_sint64()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.keys_vals)?;
                },
                80 => {
                    self.keys_vals.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_sint64_size(1, &self.id);
        if let Some(v) = self.denseinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_sint64_size(8, &self.lat);
        my_size += ::protobuf::rt::vec_packed_sint64_size(9, &self.lon);
        my_size += ::protobuf::rt::vec_packed_int32_size(10, &self.keys_vals);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_sint64(1, &self.id)?;
        if let Some(v) = self.denseinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_repeated_packed_sint64(8, &self.lat)?;
        os.write_repeated_packed_sint64(9, &self.lon)?;
        os.write_repeated_packed_int32(10, &self.keys_vals)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DenseNodes {
        DenseNodes::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.denseinfo.clear();
        self.lat.clear();
        self.lon.clear();
        self.keys_vals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DenseNodes {
        static instance: DenseNodes = DenseNodes {
            id: ::std::vec::Vec::new(),
            denseinfo: ::protobuf::MessageField::none(),
            lat: ::std::vec::Vec::new(),
            lon: ::std::vec::Vec::new(),
            keys_vals: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DenseNodes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DenseNodes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DenseNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseNodes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OSMPBF.Way)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Way {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Way.id)
    pub id: ::std::option::Option<i64>,
    ///  Parallel arrays.
    // @@protoc_insertion_point(field:OSMPBF.Way.keys)
    pub keys: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Way.vals)
    pub vals: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Way.info)
    pub info: ::protobuf::MessageField<Info>,
    // @@protoc_insertion_point(field:OSMPBF.Way.refs)
    pub refs: ::std::vec::Vec<i64>,
    ///  The following two fields are optional. They are only used in a special
    ///  format where node locations are also added to the ways. This makes the
    ///  files larger, but allows creating way geometries directly.
    ///
    ///  If this is used, you MUST set the optional_features tag "LocationsOnWays"
    ///  and the number of values in refs, lat, and lon MUST be the same.
    // @@protoc_insertion_point(field:OSMPBF.Way.lat)
    pub lat: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Way.lon)
    pub lon: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Way.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Way {
    fn default() -> &'a Way {
        <Way as ::protobuf::Message>::default_instance()
    }
}

impl Way {
    pub fn new() -> Way {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Way| { &m.id },
            |m: &mut Way| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Way| { &m.keys },
            |m: &mut Way| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vals",
            |m: &Way| { &m.vals },
            |m: &mut Way| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &Way| { &m.info },
            |m: &mut Way| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "refs",
            |m: &Way| { &m.refs },
            |m: &mut Way| { &mut m.refs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lat",
            |m: &Way| { &m.lat },
            |m: &mut Way| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lon",
            |m: &Way| { &m.lon },
            |m: &mut Way| { &mut m.lon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Way>(
            "Way",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Way {
    const NAME: &'static str = "Way";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.vals)?;
                },
                24 => {
                    self.vals.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                66 => {
                    is.read_repeated_packed_sint64_into(&mut self.refs)?;
                },
                64 => {
                    self.refs.push(is.read_sint64()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.lat)?;
                },
                72 => {
                    self.lat.push(is.read_sint64()?);
                },
                82 => {
                    is.read_repeated_packed_sint64_into(&mut self.lon)?;
                },
                80 => {
                    self.lon.push(is.read_sint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.keys);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.vals);
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_sint64_size(8, &self.refs);
        my_size += ::protobuf::rt::vec_packed_sint64_size(9, &self.lat);
        my_size += ::protobuf::rt::vec_packed_sint64_size(10, &self.lon);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.keys)?;
        os.write_repeated_packed_uint32(3, &self.vals)?;
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_repeated_packed_sint64(8, &self.refs)?;
        os.write_repeated_packed_sint64(9, &self.lat)?;
        os.write_repeated_packed_sint64(10, &self.lon)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Way {
        Way::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.refs.clear();
        self.lat.clear();
        self.lon.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Way {
        static instance: Way = Way {
            id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            vals: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            refs: ::std::vec::Vec::new(),
            lat: ::std::vec::Vec::new(),
            lon: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Way {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Way").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Way {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Way {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OSMPBF.Relation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Relation {
    // message fields
    // @@protoc_insertion_point(field:OSMPBF.Relation.id)
    pub id: ::std::option::Option<i64>,
    ///  Parallel arrays.
    // @@protoc_insertion_point(field:OSMPBF.Relation.keys)
    pub keys: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.vals)
    pub vals: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.info)
    pub info: ::protobuf::MessageField<Info>,
    ///  Parallel arrays
    // @@protoc_insertion_point(field:OSMPBF.Relation.roles_sid)
    pub roles_sid: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.memids)
    pub memids: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:OSMPBF.Relation.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<relation::MemberType>>,
    // special fields
    // @@protoc_insertion_point(special_field:OSMPBF.Relation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Relation {
    fn default() -> &'a Relation {
        <Relation as ::protobuf::Message>::default_instance()
    }
}

impl Relation {
    pub fn new() -> Relation {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Relation| { &m.id },
            |m: &mut Relation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &Relation| { &m.keys },
            |m: &mut Relation| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vals",
            |m: &Relation| { &m.vals },
            |m: &mut Relation| { &mut m.vals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Info>(
            "info",
            |m: &Relation| { &m.info },
            |m: &mut Relation| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roles_sid",
            |m: &Relation| { &m.roles_sid },
            |m: &mut Relation| { &mut m.roles_sid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "memids",
            |m: &Relation| { &m.memids },
            |m: &mut Relation| { &mut m.memids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &Relation| { &m.types },
            |m: &mut Relation| { &mut m.types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Relation>(
            "Relation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Relation {
    const NAME: &'static str = "Relation";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.vals)?;
                },
                24 => {
                    self.vals.push(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.roles_sid)?;
                },
                64 => {
                    self.roles_sid.push(is.read_int32()?);
                },
                74 => {
                    is.read_repeated_packed_sint64_into(&mut self.memids)?;
                },
                72 => {
                    self.memids.push(is.read_sint64()?);
                },
                80 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                82 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.keys);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.vals);
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_int32_size(8, &self.roles_sid);
        my_size += ::protobuf::rt::vec_packed_sint64_size(9, &self.memids);
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(10, &self.types);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_repeated_packed_uint32(2, &self.keys)?;
        os.write_repeated_packed_uint32(3, &self.vals)?;
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_repeated_packed_int32(8, &self.roles_sid)?;
        os.write_repeated_packed_sint64(9, &self.memids)?;
        os.write_repeated_packed_enum_or_unknown(10, &self.types)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Relation {
        Relation::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.keys.clear();
        self.vals.clear();
        self.info.clear();
        self.roles_sid.clear();
        self.memids.clear();
        self.types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Relation {
        static instance: Relation = Relation {
            id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            vals: ::std::vec::Vec::new(),
            info: ::protobuf::MessageField::none(),
            roles_sid: ::std::vec::Vec::new(),
            memids: ::std::vec::Vec::new(),
            types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Relation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Relation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Relation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Relation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Relation`
pub mod relation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:OSMPBF.Relation.MemberType)
    pub enum MemberType {
        // @@protoc_insertion_point(enum_value:OSMPBF.Relation.MemberType.NODE)
        NODE = 0,
        // @@protoc_insertion_point(enum_value:OSMPBF.Relation.MemberType.WAY)
        WAY = 1,
        // @@protoc_insertion_point(enum_value:OSMPBF.Relation.MemberType.RELATION)
        RELATION = 2,
    }

    impl ::protobuf::Enum for MemberType {
        const NAME: &'static str = "MemberType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MemberType> {
            match value {
                0 => ::std::option::Option::Some(MemberType::NODE),
                1 => ::std::option::Option::Some(MemberType::WAY),
                2 => ::std::option::Option::Some(MemberType::RELATION),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<MemberType> {
            match str {
                "NODE" => ::std::option::Option::Some(MemberType::NODE),
                "WAY" => ::std::option::Option::Some(MemberType::WAY),
                "RELATION" => ::std::option::Option::Some(MemberType::RELATION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MemberType] = &[
            MemberType::NODE,
            MemberType::WAY,
            MemberType::RELATION,
        ];
    }

    impl ::protobuf::EnumFull for MemberType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Relation.MemberType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MemberType {
        fn default() -> Self {
            MemberType::NODE
        }
    }

    impl MemberType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MemberType>("Relation.MemberType")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fosmformat.proto\x12\x06OSMPBF\"\xa3\x03\n\x0bHeaderBlock\x12&\n\
    \x04bbox\x18\x01\x20\x01(\x0b2\x12.OSMPBF.HeaderBBoxR\x04bbox\x12+\n\x11\
    required_features\x18\x04\x20\x03(\tR\x10requiredFeatures\x12+\n\x11opti\
    onal_features\x18\x05\x20\x03(\tR\x10optionalFeatures\x12&\n\x0ewritingp\
    rogram\x18\x10\x20\x01(\tR\x0ewritingprogram\x12\x16\n\x06source\x18\x11\
    \x20\x01(\tR\x06source\x12B\n\x1dosmosis_replication_timestamp\x18\x20\
    \x20\x01(\x03R\x1bosmosisReplicationTimestamp\x12M\n#osmosis_replication\
    _sequence_number\x18!\x20\x01(\x03R\x20osmosisReplicationSequenceNumber\
    \x12?\n\x1cosmosis_replication_base_url\x18\"\x20\x01(\tR\x19osmosisRepl\
    icationBaseUrl\"`\n\nHeaderBBox\x12\x12\n\x04left\x18\x01\x20\x02(\x12R\
    \x04left\x12\x14\n\x05right\x18\x02\x20\x02(\x12R\x05right\x12\x10\n\x03\
    top\x18\x03\x20\x02(\x12R\x03top\x12\x16\n\x06bottom\x18\x04\x20\x02(\
    \x12R\x06bottom\"\xa3\x02\n\x0ePrimitiveBlock\x125\n\x0bstringtable\x18\
    \x01\x20\x02(\x0b2\x13.OSMPBF.StringTableR\x0bstringtable\x12>\n\x0eprim\
    itivegroup\x18\x02\x20\x03(\x0b2\x16.OSMPBF.PrimitiveGroupR\x0eprimitive\
    group\x12%\n\x0bgranularity\x18\x11\x20\x01(\x05:\x03100R\x0bgranularity\
    \x12\x20\n\nlat_offset\x18\x13\x20\x01(\x03:\x010R\tlatOffset\x12\x20\n\
    \nlon_offset\x18\x14\x20\x01(\x03:\x010R\tlonOffset\x12/\n\x10date_granu\
    larity\x18\x12\x20\x01(\x05:\x041000R\x0fdateGranularity\"\xe2\x01\n\x0e\
    PrimitiveGroup\x12\"\n\x05nodes\x18\x01\x20\x03(\x0b2\x0c.OSMPBF.NodeR\
    \x05nodes\x12(\n\x05dense\x18\x02\x20\x01(\x0b2\x12.OSMPBF.DenseNodesR\
    \x05dense\x12\x1f\n\x04ways\x18\x03\x20\x03(\x0b2\x0b.OSMPBF.WayR\x04way\
    s\x12.\n\trelations\x18\x04\x20\x03(\x0b2\x10.OSMPBF.RelationR\trelation\
    s\x121\n\nchangesets\x18\x05\x20\x03(\x0b2\x11.OSMPBF.ChangeSetR\nchange\
    sets\"\x1b\n\x0bStringTable\x12\x0c\n\x01s\x18\x01\x20\x03(\x0cR\x01s\"\
    \xa7\x01\n\x04Info\x12\x1c\n\x07version\x18\x01\x20\x01(\x05:\x02-1R\x07\
    version\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\x12\x1c\n\
    \tchangeset\x18\x03\x20\x01(\x03R\tchangeset\x12\x10\n\x03uid\x18\x04\
    \x20\x01(\x05R\x03uid\x12\x19\n\x08user_sid\x18\x05\x20\x01(\rR\x07userS\
    id\x12\x18\n\x07visible\x18\x06\x20\x01(\x08R\x07visible\"\xc0\x01\n\tDe\
    nseInfo\x12\x1c\n\x07version\x18\x01\x20\x03(\x05R\x07versionB\x02\x10\
    \x01\x12\x20\n\ttimestamp\x18\x02\x20\x03(\x12R\ttimestampB\x02\x10\x01\
    \x12\x20\n\tchangeset\x18\x03\x20\x03(\x12R\tchangesetB\x02\x10\x01\x12\
    \x14\n\x03uid\x18\x04\x20\x03(\x11R\x03uidB\x02\x10\x01\x12\x1d\n\x08use\
    r_sid\x18\x05\x20\x03(\x11R\x07userSidB\x02\x10\x01\x12\x1c\n\x07visible\
    \x18\x06\x20\x03(\x08R\x07visibleB\x02\x10\x01\"\x1b\n\tChangeSet\x12\
    \x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\"\x8c\x01\n\x04Node\x12\x0e\n\
    \x02id\x18\x01\x20\x02(\x12R\x02id\x12\x16\n\x04keys\x18\x02\x20\x03(\rR\
    \x04keysB\x02\x10\x01\x12\x16\n\x04vals\x18\x03\x20\x03(\rR\x04valsB\x02\
    \x10\x01\x12\x20\n\x04info\x18\x04\x20\x01(\x0b2\x0c.OSMPBF.InfoR\x04inf\
    o\x12\x10\n\x03lat\x18\x08\x20\x02(\x12R\x03lat\x12\x10\n\x03lon\x18\t\
    \x20\x02(\x12R\x03lon\"\x9e\x01\n\nDenseNodes\x12\x12\n\x02id\x18\x01\
    \x20\x03(\x12R\x02idB\x02\x10\x01\x12/\n\tdenseinfo\x18\x05\x20\x01(\x0b\
    2\x11.OSMPBF.DenseInfoR\tdenseinfo\x12\x14\n\x03lat\x18\x08\x20\x03(\x12\
    R\x03latB\x02\x10\x01\x12\x14\n\x03lon\x18\t\x20\x03(\x12R\x03lonB\x02\
    \x10\x01\x12\x1f\n\tkeys_vals\x18\n\x20\x03(\x05R\x08keysValsB\x02\x10\
    \x01\"\xab\x01\n\x03Way\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\x12\
    \x16\n\x04keys\x18\x02\x20\x03(\rR\x04keysB\x02\x10\x01\x12\x16\n\x04val\
    s\x18\x03\x20\x03(\rR\x04valsB\x02\x10\x01\x12\x20\n\x04info\x18\x04\x20\
    \x01(\x0b2\x0c.OSMPBF.InfoR\x04info\x12\x16\n\x04refs\x18\x08\x20\x03(\
    \x12R\x04refsB\x02\x10\x01\x12\x14\n\x03lat\x18\t\x20\x03(\x12R\x03latB\
    \x02\x10\x01\x12\x14\n\x03lon\x18\n\x20\x03(\x12R\x03lonB\x02\x10\x01\"\
    \x8f\x02\n\x08Relation\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\x12\
    \x16\n\x04keys\x18\x02\x20\x03(\rR\x04keysB\x02\x10\x01\x12\x16\n\x04val\
    s\x18\x03\x20\x03(\rR\x04valsB\x02\x10\x01\x12\x20\n\x04info\x18\x04\x20\
    \x01(\x0b2\x0c.OSMPBF.InfoR\x04info\x12\x1f\n\troles_sid\x18\x08\x20\x03\
    (\x05R\x08rolesSidB\x02\x10\x01\x12\x1a\n\x06memids\x18\t\x20\x03(\x12R\
    \x06memidsB\x02\x10\x01\x125\n\x05types\x18\n\x20\x03(\x0e2\x1b.OSMPBF.R\
    elation.MemberTypeR\x05typesB\x02\x10\x01\"-\n\nMemberType\x12\x08\n\x04\
    NODE\x10\0\x12\x07\n\x03WAY\x10\x01\x12\x0c\n\x08RELATION\x10\x02B\x0f\n\
    \rcrosby.binaryJ\xd7]\n\x07\x12\x05\x16\0\x85\x02\x01\n\xc7\x08\n\x01\
    \x0c\x12\x03\x16\0\x122\xbc\x08*\x20Copyright\x20(c)\x202010\x20Scott\
    \x20A.\x20Crosby.\x20<scott@sacrosby.com>\n\nPermission\x20is\x20hereby\
    \x20granted,\x20free\x20of\x20charge,\x20to\x20any\x20person\x20obtainin\
    g\x20a\x20copy\x20of\nthis\x20software\x20and\x20associated\x20documenta\
    tion\x20files\x20(the\x20\"Software\"),\x20to\x20deal\x20in\nthe\x20Soft\
    ware\x20without\x20restriction,\x20including\x20without\x20limitation\
    \x20the\x20rights\x20to\nuse,\x20copy,\x20modify,\x20merge,\x20publish,\
    \x20distribute,\x20sublicense,\x20and/or\x20sell\x20copies\nof\x20the\
    \x20Software,\x20and\x20to\x20permit\x20persons\x20to\x20whom\x20the\x20\
    Software\x20is\x20furnished\x20to\x20do\nso,\x20subject\x20to\x20the\x20\
    following\x20conditions:\n\nThe\x20above\x20copyright\x20notice\x20and\
    \x20this\x20permission\x20notice\x20shall\x20be\x20included\x20in\x20all\
    \ncopies\x20or\x20substantial\x20portions\x20of\x20the\x20Software.\n\nT\
    HE\x20SOFTWARE\x20IS\x20PROVIDED\x20\"AS\x20IS\",\x20WITHOUT\x20WARRANTY\
    \x20OF\x20ANY\x20KIND,\x20EXPRESS\x20OR\nIMPLIED,\x20INCLUDING\x20BUT\
    \x20NOT\x20LIMITED\x20TO\x20THE\x20WARRANTIES\x20OF\x20MERCHANTABILITY,\
    \nFITNESS\x20FOR\x20A\x20PARTICULAR\x20PURPOSE\x20AND\x20NONINFRINGEMENT\
    .\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\nAUTHORS\x20OR\x20COPYRIGHT\x20HO\
    LDERS\x20BE\x20LIABLE\x20FOR\x20ANY\x20CLAIM,\x20DAMAGES\x20OR\x20OTHER\
    \nLIABILITY,\x20WHETHER\x20IN\x20AN\x20ACTION\x20OF\x20CONTRACT,\x20TORT\
    \x20OR\x20OTHERWISE,\x20ARISING\x20FROM,\nOUT\x20OF\x20OR\x20IN\x20CONNE\
    CTION\x20WITH\x20THE\x20SOFTWARE\x20OR\x20THE\x20USE\x20OR\x20OTHER\x20D\
    EALINGS\x20IN\x20THE\nSOFTWARE.\n\n\n\x08\n\x01\x08\x12\x03\x18\0&\n\t\n\
    \x02\x08\x01\x12\x03\x18\0&\n\x08\n\x01\x02\x12\x03\x19\0\x0f\n\x8e\x0b\
    \n\x02\x04\0\x12\x04>\0T\x012\xcf\t\x20OSM\x20Binary\x20file\x20format\n\
    \nThis\x20is\x20the\x20master\x20schema\x20file\x20of\x20the\x20OSM\x20b\
    inary\x20file\x20format.\x20This\nfile\x20is\x20designed\x20to\x20suppor\
    t\x20limited\x20random-access\x20and\x20future\nextendability.\n\nA\x20b\
    inary\x20OSM\x20file\x20consists\x20of\x20a\x20sequence\x20of\x20FileBlo\
    cks\x20(please\x20see\nfileformat.proto).\x20The\x20first\x20fileblock\
    \x20contains\x20a\x20serialized\x20instance\nof\x20HeaderBlock,\x20follo\
    wed\x20by\x20a\x20sequence\x20of\x20PrimitiveBlock\x20blocks\x20that\nco\
    ntain\x20the\x20primitives.\n\nEach\x20primitiveblock\x20is\x20designed\
    \x20to\x20be\x20independently\x20parsable.\x20It\ncontains\x20a\x20strin\
    g\x20table\x20storing\x20all\x20strings\x20in\x20that\x20block\x20(keys\
    \x20and\nvalues\x20in\x20tags,\x20roles\x20in\x20relations,\x20usernames\
    ,\x20etc.)\x20as\x20well\x20as\nmetadata\x20containing\x20the\x20precisi\
    on\x20of\x20coordinates\x20or\x20timestamps\x20in\x20that\nblock.\n\nA\
    \x20primitiveblock\x20contains\x20a\x20sequence\x20of\x20primitive\x20gr\
    oups,\x20each\ncontaining\x20primitives\x20of\x20the\x20same\x20type\x20\
    (nodes,\x20densenodes,\x20ways,\nrelations).\x20Coordinates\x20are\x20st\
    ored\x20in\x20signed\x2064-bit\x20integers.\x20Lat&lon\nare\x20measured\
    \x20in\x20units\x20<granularity>\x20nanodegrees.\x20The\x20default\x20of\
    \ngranularity\x20of\x20100\x20nanodegrees\x20corresponds\x20to\x20about\
    \x201cm\x20on\x20the\x20ground,\nand\x20a\x20full\x20lat\x20or\x20lon\
    \x20fits\x20into\x2032\x20bits.\n\nConverting\x20an\x20integer\x20to\x20\
    a\x20latitude\x20or\x20longitude\x20uses\x20the\x20formula:\n$OUT\x20=\
    \x20IN\x20*\x20granularity\x20/\x2010**9$.\x20Many\x20encoding\x20scheme\
    s\x20use\x20delta\ncoding\x20when\x20representing\x20nodes\x20and\x20rel\
    ations.\n\n2\x92\x01////////////////////////////////////////////////////\
    ////////////////////\n//////////////////////////////////////////////////\
    //////////////////////\n2\x1b\x20Contains\x20the\x20file\x20header.\x20\
    \n\n\n\x03\x04\0\x01\x12\x03>\x08\x13\n\x0b\n\x04\x04\0\x02\0\x12\x03?\
    \x02\x1f\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\0\
    \x02\0\x06\x12\x03?\x0b\x15\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03?\x16\x1a\
    \n\x0c\n\x05\x04\0\x02\0\x03\x12\x03?\x1d\x1e\n=\n\x04\x04\0\x02\x01\x12\
    \x03B\x02(\x1a0\x20Additional\x20tags\x20to\x20aid\x20in\x20parsing\x20t\
    his\x20dataset\x20\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03B\x02\n\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03B\x0b\x11\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03B\x12#\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03B&'\n\x0b\n\x04\x04\
    \0\x02\x02\x12\x03C\x02(\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03C\x02\n\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03C\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03C\x12#\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03C&'\n\x0b\n\x04\
    \x04\0\x02\x03\x12\x03E\x02&\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03E\x02\
    \n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03E\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03E\x12\x20\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03E#%\n#\n\
    \x04\x04\0\x02\x04\x12\x03F\x02\x1e\"\x16\x20From\x20the\x20bbox\x20fiel\
    d.\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03F\x02\n\n\x0c\n\x05\x04\0\x02\
    \x04\x05\x12\x03F\x0b\x11\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03F\x12\x18\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03F\x1b\x1d\n\xe3\x01\n\x04\x04\0\
    \x02\x05\x12\x03M\x024\x1a\xa0\x01\x20Replication\x20timestamp,\x20expre\
    ssed\x20in\x20seconds\x20since\x20the\x20epoch,\n\x20otherwise\x20the\
    \x20same\x20value\x20as\x20in\x20the\x20\"timestamp=...\"\x20field\n\x20\
    in\x20the\x20state.txt\x20file\x20used\x20by\x20Osmosis.\n23\x20Tags\x20\
    that\x20allow\x20continuing\x20an\x20Osmosis\x20replication\x20\n\x0c\n\
    \x05\x04\0\x02\x05\x04\x12\x03M\x02\n\n\x0c\n\x05\x04\0\x02\x05\x05\x12\
    \x03M\x0b\x10\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03M\x11.\n\x0c\n\x05\
    \x04\0\x02\x05\x03\x12\x03M13\nI\n\x04\x04\0\x02\x06\x12\x03P\x02:\x1a<\
    \x20Replication\x20sequence\x20number\x20(sequenceNumber\x20in\x20state.\
    txt).\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\0\
    \x02\x06\x05\x12\x03P\x0b\x10\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03P\x11\
    4\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03P79\nK\n\x04\x04\0\x02\x07\x12\
    \x03S\x024\x1a>\x20Replication\x20base\x20URL\x20(from\x20Osmosis'\x20co\
    nfiguration.txt\x20file).\n\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03S\x02\n\
    \n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03S\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x07\x01\x12\x03S\x12.\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03S13\n\xa1\
    \x01\n\x02\x04\x01\x12\x04[\0`\x012\x94\x01*\x20The\x20bounding\x20box\
    \x20field\x20in\x20the\x20OSM\x20header.\x20BBOX,\x20as\x20used\x20in\
    \x20the\x20OSM\nheader.\x20Units\x20are\x20always\x20in\x20nanodegrees\
    \x20--\x20they\x20do\x20not\x20obey\ngranularity\x20rules.\x20\n\n\n\x03\
    \x04\x01\x01\x12\x03[\x08\x12\n\x0b\n\x04\x04\x01\x02\0\x12\x03\\\x02\
    \x1b\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\\\x02\n\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\\\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\\\x12\
    \x16\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\\\x19\x1a\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03]\x02\x1c\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03]\x02\n\
    \n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03]\x0b\x11\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03]\x12\x17\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03]\
    \x1a\x1b\n\x0b\n\x04\x04\x01\x02\x02\x12\x03^\x02\x1a\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x03^\x02\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03^\
    \x0b\x11\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03^\x12\x15\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03^\x18\x19\n\x0b\n\x04\x04\x01\x02\x03\x12\
    \x03_\x02\x1d\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03_\x02\n\n\x0c\n\x05\
    \x04\x01\x02\x03\x05\x12\x03_\x0b\x11\n\x0c\n\x05\x04\x01\x02\x03\x01\
    \x12\x03_\x12\x18\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03_\x1b\x1c\n\x99\
    \x01\n\x02\x04\x02\x12\x04g\0t\x012\x8c\x01/////////////////////////////\
    ////////////////////////////////////////\n//////////////////////////////\
    ///////////////////////////////////////\n\n\n\n\x03\x04\x02\x01\x12\x03g\
    \x08\x16\n\x0b\n\x04\x04\x02\x02\0\x12\x03h\x02'\n\x0c\n\x05\x04\x02\x02\
    \0\x04\x12\x03h\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03h\x0b\x16\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03h\x17\"\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03h%&\n\x0b\n\x04\x04\x02\x02\x01\x12\x03i\x02-\n\x0c\n\x05\
    \x04\x02\x02\x01\x04\x12\x03i\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\
    \x03i\x0b\x19\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03i\x1a(\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03i+,\nZ\n\x04\x04\x02\x02\x02\x12\x03l\x020\
    \x1aM\x20Granularity,\x20units\x20of\x20nanodegrees,\x20used\x20to\x20st\
    ore\x20coordinates\x20in\x20this\x20block.\n\n\x0c\n\x05\x04\x02\x02\x02\
    \x04\x12\x03l\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03l\x0b\x10\n\
    \x0c\n\x05\x04\x02\x02\x02\x01\x12\x03l\x11\x1c\n\x0c\n\x05\x04\x02\x02\
    \x02\x03\x12\x03l\x1f!\n\x0c\n\x05\x04\x02\x02\x02\x08\x12\x03l\"/\n\x0c\
    \n\x05\x04\x02\x02\x02\x07\x12\x03l+.\nl\n\x04\x04\x02\x02\x03\x12\x03o\
    \x02-\x1a_\x20Offset\x20value\x20between\x20the\x20output\x20coordinates\
    \x20and\x20the\x20granularity\x20grid\x20in\x20units\x20of\x20nanodegree\
    s.\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x03\x05\x12\x03o\x0b\x10\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03o\
    \x11\x1b\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03o\x1e\x20\n\x0c\n\x05\
    \x04\x02\x02\x03\x08\x12\x03o!,\n\x0c\n\x05\x04\x02\x02\x03\x07\x12\x03o\
    *+\n\x0b\n\x04\x04\x02\x02\x04\x12\x03p\x02-\n\x0c\n\x05\x04\x02\x02\x04\
    \x04\x12\x03p\x02\n\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03p\x0b\x10\n\
    \x0c\n\x05\x04\x02\x02\x04\x01\x12\x03p\x11\x1b\n\x0c\n\x05\x04\x02\x02\
    \x04\x03\x12\x03p\x1e\x20\n\x0c\n\x05\x04\x02\x02\x04\x08\x12\x03p!,\n\
    \x0c\n\x05\x04\x02\x02\x04\x07\x12\x03p*+\nh\n\x04\x04\x02\x02\x05\x12\
    \x03s\x026\x1a[\x20Granularity\x20of\x20dates,\x20normally\x20represente\
    d\x20in\x20units\x20of\x20milliseconds\x20since\x20the\x201970\x20epoch.\
    \n\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03s\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x03s\x0b\x10\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03s\
    \x11!\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03s$&\n\x0c\n\x05\x04\x02\x02\
    \x05\x08\x12\x03s'5\n\x0c\n\x05\x04\x02\x02\x05\x07\x12\x03s04\nV\n\x02\
    \x04\x03\x12\x04w\0}\x01\x1aJ\x20Group\x20of\x20OSMPrimitives.\x20All\
    \x20primitives\x20in\x20a\x20group\x20must\x20be\x20the\x20same\x20type.\
    \n\n\n\n\x03\x04\x03\x01\x12\x03w\x08\x16\n\x0b\n\x04\x04\x03\x02\0\x12\
    \x03x\x02\x1a\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03x\x02\n\n\x0c\n\x05\
    \x04\x03\x02\0\x06\x12\x03x\x0b\x0f\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03x\x10\x15\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03x\x18\x19\n\x0b\n\x04\
    \x04\x03\x02\x01\x12\x03y\x02\x20\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\
    \x03y\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03y\x0b\x15\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03y\x16\x1b\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03y\x1e\x1f\n\x0b\n\x04\x04\x03\x02\x02\x12\x03z\x02\x18\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03z\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x06\
    \x12\x03z\x0b\x0e\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03z\x0f\x13\n\x0c\
    \n\x05\x04\x03\x02\x02\x03\x12\x03z\x16\x17\n\x0b\n\x04\x04\x03\x02\x03\
    \x12\x03{\x02\"\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03{\x02\n\n\x0c\n\
    \x05\x04\x03\x02\x03\x06\x12\x03{\x0b\x13\n\x0c\n\x05\x04\x03\x02\x03\
    \x01\x12\x03{\x14\x1d\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03{\x20!\n\
    \x0b\n\x04\x04\x03\x02\x04\x12\x03|\x02$\n\x0c\n\x05\x04\x03\x02\x04\x04\
    \x12\x03|\x02\n\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\x03|\x0b\x14\n\x0c\n\
    \x05\x04\x03\x02\x04\x01\x12\x03|\x15\x1f\n\x0c\n\x05\x04\x03\x02\x04\
    \x03\x12\x03|\"#\n\xbf\x01\n\x02\x04\x04\x12\x06\x86\x01\0\x88\x01\x01\
    \x1a\xb0\x01*\x20String\x20table,\x20contains\x20the\x20common\x20string\
    s\x20in\x20each\x20block.\n\nNote\x20that\x20we\x20reserve\x20index\x20'\
    0'\x20as\x20a\x20delimiter,\x20so\x20the\x20entry\x20at\x20that\nindex\
    \x20in\x20the\x20table\x20is\x20ALWAYS\x20blank\x20and\x20unused.\n\n\n\
    \x0b\n\x03\x04\x04\x01\x12\x04\x86\x01\x08\x13\n\x0c\n\x04\x04\x04\x02\0\
    \x12\x04\x87\x01\x02\x17\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x87\x01\x02\
    \n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x87\x01\x0b\x10\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\x87\x01\x11\x12\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \x87\x01\x15\x16\nK\n\x02\x04\x05\x12\x06\x8b\x01\0\x9b\x01\x01\x1a=\x20\
    Optional\x20metadata\x20that\x20may\x20be\x20included\x20into\x20each\
    \x20primitive.\x20\n\x0b\n\x03\x04\x05\x01\x12\x04\x8b\x01\x08\x0c\n\x0c\
    \n\x04\x04\x05\x02\0\x12\x04\x8c\x01\x02,\n\r\n\x05\x04\x05\x02\0\x04\
    \x12\x04\x8c\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x8c\x01\x0b\
    \x10\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x8c\x01\x11\x18\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\x8c\x01\x1b\x1c\n\r\n\x05\x04\x05\x02\0\x08\x12\
    \x04\x8c\x01\x1d+\n\r\n\x05\x04\x05\x02\0\x07\x12\x04\x8c\x01(*\n\x0c\n\
    \x04\x04\x05\x02\x01\x12\x04\x8d\x01\x02\x1f\n\r\n\x05\x04\x05\x02\x01\
    \x04\x12\x04\x8d\x01\x02\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\x8d\x01\
    \x0b\x10\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x8d\x01\x11\x1a\n\r\n\x05\
    \x04\x05\x02\x01\x03\x12\x04\x8d\x01\x1d\x1e\n\x0c\n\x04\x04\x05\x02\x02\
    \x12\x04\x8e\x01\x02\x1f\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\x8e\x01\
    \x02\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x8e\x01\x0b\x10\n\r\n\x05\
    \x04\x05\x02\x02\x01\x12\x04\x8e\x01\x11\x1a\n\r\n\x05\x04\x05\x02\x02\
    \x03\x12\x04\x8e\x01\x1d\x1e\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\x8f\x01\
    \x02\x19\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\x8f\x01\x02\n\n\r\n\x05\
    \x04\x05\x02\x03\x05\x12\x04\x8f\x01\x0b\x10\n\r\n\x05\x04\x05\x02\x03\
    \x01\x12\x04\x8f\x01\x11\x14\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\x8f\
    \x01\x17\x18\n\x1a\n\x04\x04\x05\x02\x04\x12\x04\x90\x01\x02\x1f\"\x0c\
    \x20String\x20IDs\n\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04\x90\x01\x02\n\
    \n\r\n\x05\x04\x05\x02\x04\x05\x12\x04\x90\x01\x0b\x11\n\r\n\x05\x04\x05\
    \x02\x04\x01\x12\x04\x90\x01\x12\x1a\n\r\n\x05\x04\x05\x02\x04\x03\x12\
    \x04\x90\x01\x1d\x1e\n\xbe\x03\n\x04\x04\x05\x02\x05\x12\x04\x9a\x01\x02\
    \x1c\x1a\xaf\x03\x20The\x20visible\x20flag\x20is\x20used\x20to\x20store\
    \x20history\x20information.\x20It\x20indicates\x20that\n\x20the\x20curre\
    nt\x20object\x20version\x20has\x20been\x20created\x20by\x20a\x20delete\
    \x20operation\x20on\x20the\n\x20OSM\x20API.\n\x20When\x20a\x20writer\x20\
    sets\x20this\x20flag,\x20it\x20MUST\x20add\x20a\x20required_features\x20\
    tag\x20with\n\x20value\x20\"HistoricalInformation\"\x20to\x20the\x20Head\
    erBlock.\n\x20If\x20this\x20flag\x20is\x20not\x20available\x20for\x20som\
    e\x20object\x20it\x20MUST\x20be\x20assumed\x20to\x20be\n\x20true\x20if\
    \x20the\x20file\x20has\x20the\x20required_features\x20tag\x20\"Historica\
    lInformation\"\n\x20set.\n\n\r\n\x05\x04\x05\x02\x05\x04\x12\x04\x9a\x01\
    \x02\n\n\r\n\x05\x04\x05\x02\x05\x05\x12\x04\x9a\x01\x0b\x0f\n\r\n\x05\
    \x04\x05\x02\x05\x01\x12\x04\x9a\x01\x10\x17\n\r\n\x05\x04\x05\x02\x05\
    \x03\x12\x04\x9a\x01\x1a\x1b\nu\n\x02\x04\x06\x12\x06\x9e\x01\0\xae\x01\
    \x01\x1ag*\x20Optional\x20metadata\x20that\x20may\x20be\x20included\x20i\
    nto\x20each\x20primitive.\x20Special\x20dense\x20format\x20used\x20in\
    \x20DenseNodes.\x20\n\x0b\n\x03\x04\x06\x01\x12\x04\x9e\x01\x08\x11\n\
    \x0c\n\x04\x04\x06\x02\0\x12\x04\x9f\x01\x02-\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\x9f\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x9f\x01\
    \x0b\x10\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x9f\x01\x11\x18\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\x9f\x01\x1b\x1c\n\r\n\x05\x04\x06\x02\0\x08\
    \x12\x04\x9f\x01\x1d,\n\x0e\n\x06\x04\x06\x02\0\x08\x02\x12\x04\x9f\x01\
    \x1e+\n\x1b\n\x04\x04\x06\x02\x01\x12\x04\xa0\x01\x020\"\r\x20DELTA\x20c\
    oded\n\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xa0\x01\x02\n\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xa0\x01\x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xa0\x01\x12\x1b\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa0\x01\
    \x1e\x1f\n\r\n\x05\x04\x06\x02\x01\x08\x12\x04\xa0\x01\x20/\n\x0e\n\x06\
    \x04\x06\x02\x01\x08\x02\x12\x04\xa0\x01!.\n\x1b\n\x04\x04\x06\x02\x02\
    \x12\x04\xa1\x01\x020\"\r\x20DELTA\x20coded\n\n\r\n\x05\x04\x06\x02\x02\
    \x04\x12\x04\xa1\x01\x02\n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xa1\x01\
    \x0b\x11\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xa1\x01\x12\x1b\n\r\n\x05\
    \x04\x06\x02\x02\x03\x12\x04\xa1\x01\x1e\x1f\n\r\n\x05\x04\x06\x02\x02\
    \x08\x12\x04\xa1\x01\x20/\n\x0e\n\x06\x04\x06\x02\x02\x08\x02\x12\x04\
    \xa1\x01!.\n\x1b\n\x04\x04\x06\x02\x03\x12\x04\xa2\x01\x02*\"\r\x20DELTA\
    \x20coded\n\n\r\n\x05\x04\x06\x02\x03\x04\x12\x04\xa2\x01\x02\n\n\r\n\
    \x05\x04\x06\x02\x03\x05\x12\x04\xa2\x01\x0b\x11\n\r\n\x05\x04\x06\x02\
    \x03\x01\x12\x04\xa2\x01\x12\x15\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\
    \xa2\x01\x18\x19\n\r\n\x05\x04\x06\x02\x03\x08\x12\x04\xa2\x01\x1a)\n\
    \x0e\n\x06\x04\x06\x02\x03\x08\x02\x12\x04\xa2\x01\x1b(\n5\n\x04\x04\x06\
    \x02\x04\x12\x04\xa3\x01\x02/\"'\x20String\x20IDs\x20for\x20usernames.\
    \x20DELTA\x20coded\n\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\xa3\x01\x02\n\
    \n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xa3\x01\x0b\x11\n\r\n\x05\x04\x06\
    \x02\x04\x01\x12\x04\xa3\x01\x12\x1a\n\r\n\x05\x04\x06\x02\x04\x03\x12\
    \x04\xa3\x01\x1d\x1e\n\r\n\x05\x04\x06\x02\x04\x08\x12\x04\xa3\x01\x1f.\
    \n\x0e\n\x06\x04\x06\x02\x04\x08\x02\x12\x04\xa3\x01\x20-\n\xbe\x03\n\
    \x04\x04\x06\x02\x05\x12\x04\xad\x01\x02,\x1a\xaf\x03\x20The\x20visible\
    \x20flag\x20is\x20used\x20to\x20store\x20history\x20information.\x20It\
    \x20indicates\x20that\n\x20the\x20current\x20object\x20version\x20has\
    \x20been\x20created\x20by\x20a\x20delete\x20operation\x20on\x20the\n\x20\
    OSM\x20API.\n\x20When\x20a\x20writer\x20sets\x20this\x20flag,\x20it\x20M\
    UST\x20add\x20a\x20required_features\x20tag\x20with\n\x20value\x20\"Hist\
    oricalInformation\"\x20to\x20the\x20HeaderBlock.\n\x20If\x20this\x20flag\
    \x20is\x20not\x20available\x20for\x20some\x20object\x20it\x20MUST\x20be\
    \x20assumed\x20to\x20be\n\x20true\x20if\x20the\x20file\x20has\x20the\x20\
    required_features\x20tag\x20\"HistoricalInformation\"\n\x20set.\n\n\r\n\
    \x05\x04\x06\x02\x05\x04\x12\x04\xad\x01\x02\n\n\r\n\x05\x04\x06\x02\x05\
    \x05\x12\x04\xad\x01\x0b\x0f\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\xad\
    \x01\x10\x17\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xad\x01\x1a\x1b\n\r\n\
    \x05\x04\x06\x02\x05\x08\x12\x04\xad\x01\x1c+\n\x0e\n\x06\x04\x06\x02\
    \x05\x08\x02\x12\x04\xad\x01\x1d*\nO\n\x02\x04\x07\x12\x06\xb2\x01\0\xb4\
    \x01\x01\x1aA\x20This\x20is\x20kept\x20for\x20backwards\x20compatibility\
    \x20but\x20not\x20used\x20anywhere.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\
    \xb2\x01\x08\x11\n\x0c\n\x04\x04\x07\x02\0\x12\x04\xb3\x01\x02\x18\n\r\n\
    \x05\x04\x07\x02\0\x04\x12\x04\xb3\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x05\
    \x12\x04\xb3\x01\x0b\x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb3\x01\x11\
    \x13\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb3\x01\x16\x17\n\x0c\n\x02\x04\
    \x08\x12\x06\xb7\x01\0\xc2\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\xb7\
    \x01\x08\x0c\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xb8\x01\x02\x19\n\r\n\x05\
    \x04\x08\x02\0\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\xb8\x01\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xb8\x01\x12\x14\
    \n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xb8\x01\x17\x18\n/\n\x04\x04\x08\
    \x02\x01\x12\x04\xbb\x01\x02+\x1a\x12\x20Parallel\x20arrays.\n\"\r\x20St\
    ring\x20IDs.\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xbb\x01\x02\n\n\r\n\
    \x05\x04\x08\x02\x01\x05\x12\x04\xbb\x01\x0b\x11\n\r\n\x05\x04\x08\x02\
    \x01\x01\x12\x04\xbb\x01\x12\x16\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\
    \xbb\x01\x19\x1a\n\r\n\x05\x04\x08\x02\x01\x08\x12\x04\xbb\x01\x1b*\n\
    \x0e\n\x06\x04\x08\x02\x01\x08\x02\x12\x04\xbb\x01\x1c)\n\x1b\n\x04\x04\
    \x08\x02\x02\x12\x04\xbc\x01\x02+\"\r\x20String\x20IDs.\n\n\r\n\x05\x04\
    \x08\x02\x02\x04\x12\x04\xbc\x01\x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\
    \x04\xbc\x01\x0b\x11\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xbc\x01\x12\
    \x16\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xbc\x01\x19\x1a\n\r\n\x05\x04\
    \x08\x02\x02\x08\x12\x04\xbc\x01\x1b*\n\x0e\n\x06\x04\x08\x02\x02\x08\
    \x02\x12\x04\xbc\x01\x1c)\n*\n\x04\x04\x08\x02\x03\x12\x04\xbe\x01\x02\
    \x19\"\x1c\x20May\x20be\x20omitted\x20in\x20omitmeta\n\n\r\n\x05\x04\x08\
    \x02\x03\x04\x12\x04\xbe\x01\x02\n\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\
    \xbe\x01\x0b\x0f\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xbe\x01\x10\x14\n\
    \r\n\x05\x04\x08\x02\x03\x03\x12\x04\xbe\x01\x17\x18\n\x0c\n\x04\x04\x08\
    \x02\x04\x12\x04\xc0\x01\x02\x1a\n\r\n\x05\x04\x08\x02\x04\x04\x12\x04\
    \xc0\x01\x02\n\n\r\n\x05\x04\x08\x02\x04\x05\x12\x04\xc0\x01\x0b\x11\n\r\
    \n\x05\x04\x08\x02\x04\x01\x12\x04\xc0\x01\x12\x15\n\r\n\x05\x04\x08\x02\
    \x04\x03\x12\x04\xc0\x01\x18\x19\n\x0c\n\x04\x04\x08\x02\x05\x12\x04\xc1\
    \x01\x02\x1a\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\xc1\x01\x02\n\n\r\n\
    \x05\x04\x08\x02\x05\x05\x12\x04\xc1\x01\x0b\x11\n\r\n\x05\x04\x08\x02\
    \x05\x01\x12\x04\xc1\x01\x12\x15\n\r\n\x05\x04\x08\x02\x05\x03\x12\x04\
    \xc1\x01\x18\x19\n\x91\x03\n\x02\x04\t\x12\x06\xd0\x01\0\xda\x01\x012\
    \x82\x03\x20Used\x20to\x20densly\x20represent\x20a\x20sequence\x20of\x20\
    nodes\x20that\x20do\x20not\x20have\x20any\x20tags.\n\nWe\x20represent\
    \x20these\x20nodes\x20columnwise\x20as\x20five\x20columns:\x20ID's,\x20l\
    ats,\x20and\nlons,\x20all\x20delta\x20coded.\x20When\x20metadata\x20is\
    \x20not\x20omitted,\n\nWe\x20encode\x20keys\x20&\x20vals\x20for\x20all\
    \x20nodes\x20as\x20a\x20single\x20array\x20of\x20integers\ncontaining\
    \x20key-stringid\x20and\x20val-stringid,\x20using\x20a\x20stringid\x20of\
    \x200\x20as\x20a\ndelimiter\x20between\x20nodes.\n\n(\x20(<keyid>\x20<va\
    lid>)*\x20'0'\x20)*\n\n\x0b\n\x03\x04\t\x01\x12\x04\xd0\x01\x08\x12\n\
    \x1b\n\x04\x04\t\x02\0\x12\x04\xd1\x01\x02)\"\r\x20DELTA\x20coded\n\n\r\
    \n\x05\x04\t\x02\0\x04\x12\x04\xd1\x01\x02\n\n\r\n\x05\x04\t\x02\0\x05\
    \x12\x04\xd1\x01\x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xd1\x01\x12\
    \x14\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd1\x01\x17\x18\n\r\n\x05\x04\t\
    \x02\0\x08\x12\x04\xd1\x01\x19(\n\x0e\n\x06\x04\t\x02\0\x08\x02\x12\x04\
    \xd1\x01\x1a'\n\x0c\n\x04\x04\t\x02\x01\x12\x04\xd3\x01\x02#\n\r\n\x05\
    \x04\t\x02\x01\x04\x12\x04\xd3\x01\x02\n\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\xd3\x01\x0b\x14\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xd3\x01\x15\x1e\
    \n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xd3\x01!\"\n\x1b\n\x04\x04\t\x02\
    \x02\x12\x04\xd5\x01\x02*\"\r\x20DELTA\x20coded\n\n\r\n\x05\x04\t\x02\
    \x02\x04\x12\x04\xd5\x01\x02\n\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xd5\
    \x01\x0b\x11\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xd5\x01\x12\x15\n\r\n\
    \x05\x04\t\x02\x02\x03\x12\x04\xd5\x01\x18\x19\n\r\n\x05\x04\t\x02\x02\
    \x08\x12\x04\xd5\x01\x1a)\n\x0e\n\x06\x04\t\x02\x02\x08\x02\x12\x04\xd5\
    \x01\x1b(\n\x1b\n\x04\x04\t\x02\x03\x12\x04\xd6\x01\x02*\"\r\x20DELTA\
    \x20coded\n\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xd6\x01\x02\n\n\r\n\x05\
    \x04\t\x02\x03\x05\x12\x04\xd6\x01\x0b\x11\n\r\n\x05\x04\t\x02\x03\x01\
    \x12\x04\xd6\x01\x12\x15\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xd6\x01\x18\
    \x19\n\r\n\x05\x04\t\x02\x03\x08\x12\x04\xd6\x01\x1a)\n\x0e\n\x06\x04\t\
    \x02\x03\x08\x02\x12\x04\xd6\x01\x1b(\nu\n\x04\x04\t\x02\x04\x12\x04\xd9\
    \x01\x020\x1ag\x20Special\x20packing\x20of\x20keys\x20and\x20vals\x20int\
    o\x20one\x20array.\x20May\x20be\x20empty\x20if\x20all\x20nodes\x20in\x20\
    this\x20block\x20are\x20tagless.\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\
    \xd9\x01\x02\n\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xd9\x01\x0b\x10\n\r\n\
    \x05\x04\t\x02\x04\x01\x12\x04\xd9\x01\x11\x1a\n\r\n\x05\x04\t\x02\x04\
    \x03\x12\x04\xd9\x01\x1d\x1f\n\r\n\x05\x04\t\x02\x04\x08\x12\x04\xd9\x01\
    \x20/\n\x0e\n\x06\x04\t\x02\x04\x08\x02\x12\x04\xd9\x01!.\n\x0c\n\x02\
    \x04\n\x12\x06\xdd\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xdd\
    \x01\x08\x0b\n\x0c\n\x04\x04\n\x02\0\x12\x04\xde\x01\x02\x18\n\r\n\x05\
    \x04\n\x02\0\x04\x12\x04\xde\x01\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \xde\x01\x0b\x10\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xde\x01\x11\x13\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\xde\x01\x16\x17\n\x20\n\x04\x04\n\x02\x01\
    \x12\x04\xe1\x01\x02+\x1a\x12\x20Parallel\x20arrays.\n\n\r\n\x05\x04\n\
    \x02\x01\x04\x12\x04\xe1\x01\x02\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \xe1\x01\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xe1\x01\x12\x16\n\r\
    \n\x05\x04\n\x02\x01\x03\x12\x04\xe1\x01\x19\x1a\n\r\n\x05\x04\n\x02\x01\
    \x08\x12\x04\xe1\x01\x1b*\n\x0e\n\x06\x04\n\x02\x01\x08\x02\x12\x04\xe1\
    \x01\x1c)\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xe2\x01\x02+\n\r\n\x05\x04\n\
    \x02\x02\x04\x12\x04\xe2\x01\x02\n\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\
    \xe2\x01\x0b\x11\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xe2\x01\x12\x16\n\r\
    \n\x05\x04\n\x02\x02\x03\x12\x04\xe2\x01\x19\x1a\n\r\n\x05\x04\n\x02\x02\
    \x08\x12\x04\xe2\x01\x1b*\n\x0e\n\x06\x04\n\x02\x02\x08\x02\x12\x04\xe2\
    \x01\x1c)\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xe4\x01\x02\x19\n\r\n\x05\
    \x04\n\x02\x03\x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\x04\n\x02\x03\x06\x12\
    \x04\xe4\x01\x0b\x0f\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xe4\x01\x10\x14\
    \n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xe4\x01\x17\x18\n\x1b\n\x04\x04\n\
    \x02\x04\x12\x04\xe6\x01\x02+\"\r\x20DELTA\x20coded\n\n\r\n\x05\x04\n\
    \x02\x04\x04\x12\x04\xe6\x01\x02\n\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\
    \xe6\x01\x0b\x11\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xe6\x01\x12\x16\n\r\
    \n\x05\x04\n\x02\x04\x03\x12\x04\xe6\x01\x19\x1a\n\r\n\x05\x04\n\x02\x04\
    \x08\x12\x04\xe6\x01\x1b*\n\x0e\n\x06\x04\n\x02\x04\x08\x02\x12\x04\xe6\
    \x01\x1c)\n\x82\x03\n\x04\x04\n\x02\x05\x12\x04\xee\x01\x02*\x1a\xda\x02\
    \x20The\x20following\x20two\x20fields\x20are\x20optional.\x20They\x20are\
    \x20only\x20used\x20in\x20a\x20special\n\x20format\x20where\x20node\x20l\
    ocations\x20are\x20also\x20added\x20to\x20the\x20ways.\x20This\x20makes\
    \x20the\n\x20files\x20larger,\x20but\x20allows\x20creating\x20way\x20geo\
    metries\x20directly.\n\n\x20If\x20this\x20is\x20used,\x20you\x20MUST\x20\
    set\x20the\x20optional_features\x20tag\x20\"LocationsOnWays\"\n\x20and\
    \x20the\x20number\x20of\x20values\x20in\x20refs,\x20lat,\x20and\x20lon\
    \x20MUST\x20be\x20the\x20same.\n\"\x17\x20DELTA\x20coded,\x20optional\n\
    \n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xee\x01\x02\n\n\r\n\x05\x04\n\x02\
    \x05\x05\x12\x04\xee\x01\x0b\x11\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xee\
    \x01\x12\x15\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xee\x01\x18\x19\n\r\n\
    \x05\x04\n\x02\x05\x08\x12\x04\xee\x01\x1a)\n\x0e\n\x06\x04\n\x02\x05\
    \x08\x02\x12\x04\xee\x01\x1b(\n%\n\x04\x04\n\x02\x06\x12\x04\xef\x01\x02\
    +\"\x17\x20DELTA\x20coded,\x20optional\n\n\r\n\x05\x04\n\x02\x06\x04\x12\
    \x04\xef\x01\x02\n\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\xef\x01\x0b\x11\n\
    \r\n\x05\x04\n\x02\x06\x01\x12\x04\xef\x01\x12\x15\n\r\n\x05\x04\n\x02\
    \x06\x03\x12\x04\xef\x01\x18\x1a\n\r\n\x05\x04\n\x02\x06\x08\x12\x04\xef\
    \x01\x1b*\n\x0e\n\x06\x04\n\x02\x06\x08\x02\x12\x04\xef\x01\x1c)\n\x0c\n\
    \x02\x04\x0b\x12\x06\xf2\x01\0\x85\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xf2\x01\x08\x10\n\x0e\n\x04\x04\x0b\x04\0\x12\x06\xf3\x01\x02\xf7\
    \x01\x03\n\r\n\x05\x04\x0b\x04\0\x01\x12\x04\xf3\x01\x07\x11\n\x0e\n\x06\
    \x04\x0b\x04\0\x02\0\x12\x04\xf4\x01\x04\r\n\x0f\n\x07\x04\x0b\x04\0\x02\
    \0\x01\x12\x04\xf4\x01\x04\x08\n\x0f\n\x07\x04\x0b\x04\0\x02\0\x02\x12\
    \x04\xf4\x01\x0b\x0c\n\x0e\n\x06\x04\x0b\x04\0\x02\x01\x12\x04\xf5\x01\
    \x04\x0c\n\x0f\n\x07\x04\x0b\x04\0\x02\x01\x01\x12\x04\xf5\x01\x04\x07\n\
    \x0f\n\x07\x04\x0b\x04\0\x02\x01\x02\x12\x04\xf5\x01\n\x0b\n\x0e\n\x06\
    \x04\x0b\x04\0\x02\x02\x12\x04\xf6\x01\x04\x11\n\x0f\n\x07\x04\x0b\x04\0\
    \x02\x02\x01\x12\x04\xf6\x01\x04\x0c\n\x0f\n\x07\x04\x0b\x04\0\x02\x02\
    \x02\x12\x04\xf6\x01\x0f\x10\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xf9\x01\
    \x02\x18\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xf9\x01\x02\n\n\r\n\x05\x04\
    \x0b\x02\0\x05\x12\x04\xf9\x01\x0b\x10\n\r\n\x05\x04\x0b\x02\0\x01\x12\
    \x04\xf9\x01\x11\x13\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xf9\x01\x16\x17\
    \n\x20\n\x04\x04\x0b\x02\x01\x12\x04\xfc\x01\x02+\x1a\x12\x20Parallel\
    \x20arrays.\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xfc\x01\x02\n\n\r\n\
    \x05\x04\x0b\x02\x01\x05\x12\x04\xfc\x01\x0b\x11\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\xfc\x01\x12\x16\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xfc\x01\x19\x1a\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xfc\x01\x1b*\n\
    \x0e\n\x06\x04\x0b\x02\x01\x08\x02\x12\x04\xfc\x01\x1c)\n\x0c\n\x04\x04\
    \x0b\x02\x02\x12\x04\xfd\x01\x02+\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\
    \xfd\x01\x02\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xfd\x01\x0b\x11\n\r\
    \n\x05\x04\x0b\x02\x02\x01\x12\x04\xfd\x01\x12\x16\n\r\n\x05\x04\x0b\x02\
    \x02\x03\x12\x04\xfd\x01\x19\x1a\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\
    \xfd\x01\x1b*\n\x0e\n\x06\x04\x0b\x02\x02\x08\x02\x12\x04\xfd\x01\x1c)\n\
    \x0c\n\x04\x04\x0b\x02\x03\x12\x04\xff\x01\x02\x19\n\r\n\x05\x04\x0b\x02\
    \x03\x04\x12\x04\xff\x01\x02\n\n\r\n\x05\x04\x0b\x02\x03\x06\x12\x04\xff\
    \x01\x0b\x0f\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xff\x01\x10\x14\n\r\n\
    \x05\x04\x0b\x02\x03\x03\x12\x04\xff\x01\x17\x18\n\x7f\n\x04\x04\x0b\x02\
    \x04\x12\x04\x82\x02\x02/\x1a\x11\x20Parallel\x20arrays\n\"^\x20This\x20\
    should\x20have\x20been\x20defined\x20as\x20uint32\x20for\x20consistency,\
    \x20but\x20it\x20is\x20now\x20too\x20late\x20to\x20change\x20it\n\n\r\n\
    \x05\x04\x0b\x02\x04\x04\x12\x04\x82\x02\x02\n\n\r\n\x05\x04\x0b\x02\x04\
    \x05\x12\x04\x82\x02\x0b\x10\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x82\
    \x02\x11\x1a\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x82\x02\x1d\x1e\n\r\n\
    \x05\x04\x0b\x02\x04\x08\x12\x04\x82\x02\x1f.\n\x0e\n\x06\x04\x0b\x02\
    \x04\x08\x02\x12\x04\x82\x02\x20-\n\x1d\n\x04\x04\x0b\x02\x05\x12\x04\
    \x83\x02\x02-\"\x0f\x20DELTA\x20encoded\n\n\r\n\x05\x04\x0b\x02\x05\x04\
    \x12\x04\x83\x02\x02\n\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x83\x02\x0b\
    \x11\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x83\x02\x12\x18\n\r\n\x05\x04\
    \x0b\x02\x05\x03\x12\x04\x83\x02\x1b\x1c\n\r\n\x05\x04\x0b\x02\x05\x08\
    \x12\x04\x83\x02\x1d,\n\x0e\n\x06\x04\x0b\x02\x05\x08\x02\x12\x04\x83\
    \x02\x1e+\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\x84\x02\x021\n\r\n\x05\x04\
    \x0b\x02\x06\x04\x12\x04\x84\x02\x02\n\n\r\n\x05\x04\x0b\x02\x06\x06\x12\
    \x04\x84\x02\x0b\x15\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\x84\x02\x16\
    \x1b\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x84\x02\x1e\x20\n\r\n\x05\x04\
    \x0b\x02\x06\x08\x12\x04\x84\x02!0\n\x0e\n\x06\x04\x0b\x02\x06\x08\x02\
    \x12\x04\x84\x02\"/\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(HeaderBlock::generated_message_descriptor_data());
            messages.push(HeaderBBox::generated_message_descriptor_data());
            messages.push(PrimitiveBlock::generated_message_descriptor_data());
            messages.push(PrimitiveGroup::generated_message_descriptor_data());
            messages.push(StringTable::generated_message_descriptor_data());
            messages.push(Info::generated_message_descriptor_data());
            messages.push(DenseInfo::generated_message_descriptor_data());
            messages.push(ChangeSet::generated_message_descriptor_data());
            messages.push(Node::generated_message_descriptor_data());
            messages.push(DenseNodes::generated_message_descriptor_data());
            messages.push(Way::generated_message_descriptor_data());
            messages.push(Relation::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(relation::MemberType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
